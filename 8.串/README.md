# 串

在第一次看完KMP算法的时候，是这种感觉，基本概念和定义以及KMP解决了暴力匹配（朴素匹配）带来的问题，这些都可以快速理解。但在写代码期间始终没办法理解这个next数组（也就是“部分匹配表”）具体是一个怎么样的规律，这里记录一下后续对“部分匹配表”的总结。

## 前缀和后缀

首先我们先了解一下串的“前缀”和“后缀”是什么？以模式串"ABCDABD"为例：

- "A"的前缀和后缀都为空集，共有元素的长度为0；

- "AB"的前缀为[A]，后缀为[B]，共有元素的长度为0；

- "ABC"的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；

- "ABCD"的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；

- "ABCDA"的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为"A"，长度为1；

- "ABCDAB"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为"AB"，长度为2；

- "ABCDABD"的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。

| 索引                  | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| :-------------------- | :--- | ---- | ---- | ---- | ---- | ---- | ---- |
| 模式串（T，待匹配串） | A    | B    | C    | D    | A    | B    | D    |
| next数组              | 0    | 0    | 0    | 0    | 1    | 2    | 0    |

## 提出问题

### 为什么根据`前后缀`的`最长共有元素的长度`来实现在`模式串`和`主串`不匹配情况下的跳转呢？

同问题：如何判断在上一次匹配失败后模式串向后移动的距离呢？

我们看完KMP的基础概念和原理，所推导的结论：

- 匹配失败后模式串移动的距离和主串没有关系，只与模式串本身有关系。
- 模式串（待匹配串）移动的`指针j`的变化，与主串其实没有什么关系，关键就取决于模式串结构中是否有重复字符的问题。

以上结论一样，不同说法而已

而为啥需要这个next数组，这个数组中的数值，是来告诉你，在模式串与主串不匹配的前提下，在下一次循环匹配中，模式串从该从哪个位置开始遍历匹配，以达到避免不必要比较（朴素匹配的问题）的目的。



# 参考

[字符串匹配的KMP算法](https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)

[KMP算法（快速模式匹配算法）C语言详解](http://data.biancheng.net/view/180.html)
